#include <callgfanlib_conversion.h>
#include <containsMonomial.h>
#include <tropical.h>
#include <initial.h>
#include <groebnerCone.h>
#include <neighbours.h>
#include <tropicalStrategy.h>
#include <tropicalCurves.h>
#include <bbcone.h>
#include <tropicalVariety.h>


// /***
//  * Given a ring with ordering a(v'),ws(w'),
//  * changes the weights to v,w
//  **/
// bool changeAWSWeights(ring r, gfan::ZVector v, gfan::ZVector w)
// {
//   omFree(r->wvhdl[0]);
//   omFree(r->wvhdl[1]);
//   bool ok = false;
//   r->wvhdl[0]  = ZVectorToIntStar(v,ok);
//   r->wvhdl[1]  = ZVectorToIntStar(w,ok);
//   return ok;
// }


gfan::ZVector findTropicalPoint(const groebnerConeData sigma)
{
  ideal I = sigma.getIdeal();
  ring r = sigma.getRing();
  gfan::ZCone zc = sigma.getCone();
  gfan::ZMatrix R = zc.extremeRays();
  for (int i=0; i<R.getHeight(); i++)
  {
    // std::cout << "checking ray generated by " << R[i] << std::endl;
    ideal inI = initial(I,r,R[i]);
    poly s = checkForMonomialViaSuddenSaturation(inI,r);
    id_Delete(&inI,r);
    if (s == NULL)
    {
      p_Delete(&s,r);
      return R[i];
    }
    p_Delete(&s,r);
  }
  return gfan::ZVector();
}


/***
 * Computes a starting point by computing the Groebner fan,
 * checking each new cone whether its contains a ray in the tropical variety.
 **/
gfan::ZVector tropicalStartingPointViaGroebnerFan(const ideal I, const ring r, const tropicalStrategy currentCase)
{
  bool (*red)(ideal I, ring r);
  red = currentCase.reduce; red(I,r);

  groebnerConeData sigma = maximalGroebnerConeData(id_Copy(I,r),rCopy(r));
  gfan::ZVector startingPoint = findTropicalPoint(sigma);
  if (startingPoint.size() > 0)
    return startingPoint;
  setOfGroebnerConeData groebnerFan;
  setOfGroebnerConeData workingList;
  workingList.insert(sigma);

  while (!workingList.empty())
  {
    sigma = *(workingList.begin());
    setOfGroebnerConeData neighbours = groebnerNeighbours(sigma,currentCase);
    for (setOfGroebnerConeData::iterator tau = neighbours.begin(); tau!=neighbours.end(); tau++)
    {
      if (groebnerFan.count(*tau) == 0)
      {
        if (workingList.count(*tau) == 0)
        {
          startingPoint = findTropicalPoint(*tau);
          if (startingPoint.size() > 0)
            return startingPoint;
        }
        workingList.insert(*tau);
      }
    }
    groebnerFan.insert(groebnerConeData(sigma));
    workingList.erase(sigma);
  }
  return startingPoint;
}

BOOLEAN tropicalStartingPoint0(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZVector startingPoint = tropicalStartingPoint(I,currRing,nonValuedCase);
  id_Delete(&I, currRing);
  res->rtyp = BIGINTMAT_CMD;
  res->data = (char*) zVectorToBigintmat(startingPoint);
  return FALSE;
}

BOOLEAN tropicalStartingPoint1(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZVector startingPoint = tropicalStartingPoint(I,currRing,valuedCase);
  id_Delete(&I, currRing);
  res->rtyp = BIGINTMAT_CMD;
  res->data = (char*) zVectorToBigintmat(startingPoint);
  return FALSE;
}

gfan::ZCone tropicalStartingCone(const ideal I, const ring r, const tropicalStrategy currentCase)
{
  // groebnerConeData sigma = maximalGroebnerConeData(I,r);
  // gfan::ZCone zc = sigma.getCone();
  // if (zc.dimensionOfLinealitySpace == d)
  //   return zc.linealitySpace();
  // gfan::ZVector w = tropicalStartingPoint(I,r,currentCase);
  // ideal inI = initial(I,w,r);
  // gfan::ZCone zd =

  gfan::ZVector w = tropicalStartingPoint(I,r,currentCase);
  if (w.size() == 0)
  {
    gfan::ZCone zc = fullGroebnerCone(I,r);
    return zc.linealitySpace();
  }
  ideal inI = initial(I,r,w);
  std::set<gfan::ZCone> T = tropicalCurve(inI,r,0,currentCase);
  return *T.begin();
}

BOOLEAN tropicalStartingCone0(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZCone startingCone = tropicalStartingCone(I,currRing,nonValuedCase);
  id_Delete(&I, currRing);
  res->rtyp = coneID;
  res->data = (char*) new gfan::ZCone(startingCone);
  return FALSE;
}

BOOLEAN tropicalStartingCone1(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZCone startingCone = tropicalStartingCone(I,currRing,valuedCase);
  id_Delete(&I, currRing);
  res->rtyp = coneID;
  res->data = (char*) new gfan::ZCone(startingCone);
  return FALSE;
}
