#include <callgfanlib_conversion.h>
#include <containsMonomial.h>
#include <tropical.h>
#include <initial.h>
#include <groebnerCone.h>
#include <neighbours.h>
#include <tropicalStrategy.h>

/***
 * Given a general ring r with any ordering,
 * changes the ordering to a(v),ws(-w)
 **/
bool changetoAWSRing(ring r, gfan::ZVector v, gfan::ZVector w)
{
  omFree(r->order);
  r->order  = (int*) omAlloc0(4*sizeof(int));
  omFree(r->block0);
  r->block0 = (int*) omAlloc0(4*sizeof(int));
  omFree(r->block1);
  r->block1 = (int*) omAlloc0(4*sizeof(int));
  for (int i=0; r->wvhdl[i]; i++)
  { omFree(r->wvhdl[i]); }
  omFree(r->wvhdl);
  r->wvhdl  = (int**) omAlloc0(4*sizeof(int*));

  bool ok = false;
  r->order[0]  = ringorder_a;
  r->block0[0] = 1;
  r->block1[0] = r->N;
  r->wvhdl[0]  = ZVectorToIntStar(v,ok);
  r->order[1]  = ringorder_ws;
  r->block0[1] = 1;
  r->block1[1] = r->N;
  r->wvhdl[1]  = ZVectorToIntStar(w,ok);
  r->order[2]  = ringorder_C;
  return ok;
}


/***
 * Given a ring with ordering a(v'),ws(w'),
 * changes the weights to v,w
 **/
bool changeAWSWeights(ring r, gfan::ZVector v, gfan::ZVector w)
{
  omFree(r->wvhdl[0]);
  omFree(r->wvhdl[1]);
  bool ok = false;
  r->wvhdl[0]  = ZVectorToIntStar(v,ok);
  r->wvhdl[1]  = ZVectorToIntStar(w,ok);
  return ok;
}


gfan::ZVector findTropicalPoint(const groebnerConeData sigma)
{
  ideal I = sigma.getIdeal();
  ring r = sigma.getRing();
  gfan::ZCone zc = sigma.getCone();
  gfan::ZMatrix R = zc.extremeRays();
  for (int i=0; i<R.getHeight(); i++)
  {
    // std::cout << "checking ray generated by " << R[i] << std::endl;
    ideal inI = initial(I,r,R[i]);
    poly s = checkForMonomialViaSuddenSaturation(inI,r);
    id_Delete(&inI,r);
    if (s == NULL)
    {
      // std::cout << "found no monomial in initial ideal!" << std::endl;
      p_Delete(&s,r);
      return R[i];
    }
    p_Delete(&s,r);
  }
  gfan::ZMatrix L = zc.generatorsOfLinealitySpace();
  for (int i=0; i<L.getHeight(); i++)
  {
    ideal inI = initial(I,r,L[i]);
    poly s = checkForMonomialViaSuddenSaturation(inI,r);
    id_Delete(&inI,r);
    if (s == NULL)
    {
      // std::cout << "found no monomial in initial ideal!" << std::endl;
      p_Delete(&s,r);
      return L[i];
    }
    p_Delete(&s,r);
  }
  return gfan::ZVector();
}


gfan::ZVector tropicalStartingPoint(const ideal I, const ring r, const tropicalStrategy currentCase)
{
  groebnerConeData sigma = maximalGroebnerConeData(id_Copy(I,r),rCopy(r));
  gfan::ZVector startingPoint = findTropicalPoint(sigma);
  while (startingPoint.size()==0)
  {
    setOfGroebnerConeData neighbours = groebnerNeighbours(sigma,currentCase);
    setOfGroebnerConeData::iterator tau = neighbours.begin();
    for (; tau!=neighbours.end(); tau++)
    {
      startingPoint = findTropicalPoint(*tau);
      if (startingPoint.size() > 0) break;
    }
    tau = neighbours.begin();
    sigma = *tau;
  }
  return startingPoint;
}


BOOLEAN tropicalStartingPoint0(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZVector startingPoint = tropicalStartingPoint(I,currRing,nonValuedCase);
  id_Delete(&I, currRing);
  res->rtyp = BIGINTMAT_CMD;
  res->data = (char*) zVectorToBigintmat(startingPoint);
  return FALSE;
}

BOOLEAN tropicalStartingPoint1(leftv res, leftv args)
{
  leftv u = args;
  ideal I = (ideal) u->CopyD();
  gfan::ZVector startingPoint = tropicalStartingPoint(I,currRing,valuedCase);
  id_Delete(&I, currRing);
  res->rtyp = BIGINTMAT_CMD;
  res->data = (char*) zVectorToBigintmat(startingPoint);
  return FALSE;
}


// gfan::ZCone* tropicalStartingCone(const ideal &I, ring r)
// {
//   gfan::ZVector* w = tropicalStartingPoint(I,r);
//   return groebnerCone(I,r,w);
// }
